BIG_NUM = 1000000007

"""

프로그래머스 레벨 2의 [2*n 타일링](https://school.programmers.co.kr/learn/courses/30/lessons/12900), 
[3*n 타일링](https://school.programmers.co.kr/learn/courses/30/lessons/12902) 문제의 변형 버전 문제.

기본적으로 DP인 건 같은데, 타일이 기존 문제보다 복잡하게 생겨서 어떤 케이스가 있을 수 있는지 훨씬 꼼꼼히 생각해야 하는 문제.

3*1, 3*2, 3*3 영역을 채우는 가지수가 1, 2, 5가지 있다는 건 떠올리기 쉽고 기존 문제 푸는 방식과 완전히 똑같이 처리하면 되는데,
3*4나 3*5, 3*6 영역을 채우는 가지수가 더 있을 수 있으며 
이와 같은 패턴이 4, 7, 10, ... / 5, 8, 11, ... / 6, 9, 12 ... 이런 식으로 이어진다는 걸 생각하면 
이 문제의 해답은 O(n^2)이고 더 빠른 풀이는 없다고 생각할 수 있다.

그러나 O(n^2)를 구현한 코드를 잘 살펴보면 충분히 시간복잡도를 줄일 방법을 금세 떠올릴 수 있다. 
```
        for j in range(1, i//3 + 1):
            if i >= 1 + 3 * j:
                dy[-1] = (dy[-1] + dy[i - 1 - 3 * j] * 2) % BIG_NUM
            if i >= 2 + 3 * j:
                dy[-1] = (dy[-1] + dy[i - 2 - 3 * j] * 2) % BIG_NUM
            if i >= 3 + 3 * j:
                dy[-1] = (dy[-1] + dy[i - 3 - 3 * j] * 4) % BIG_NUM
```

현재 dy값을 계산할 때 어차피 과거 특정 시점의 어떤 값이 꼭 필요한 게 아니라 '여태까지의 합'이 필요한 것이므로, 
위와 같이 중복해서 루프를 돌 게 아니라, 그냥 과거 특정 시점의 값들을 모두 누적한 변수를 하나 추가해서 이를 계속 누적하며 반복 사용하면 된다.

"""


def solution(n):
    dy = [1, 1, 3, 10, 23, 62]
    sum_by_rem = [1, 1, 3, 11, 24, 65]
    for i in range(6, n + 1):
        dy.append(0)
        dy[-1] = (dy[-2] + dy[-3] * 2 + dy[-4] * 5) % BIG_NUM
        dy[-1] = (dy[-1] + sum_by_rem[i % 3] * 4 + sum_by_rem[(i + 1) % 3] * 2 + sum_by_rem[(i + 2) % 3] * 2) % BIG_NUM

        # 현재 i에 대해 계산된 결괏값을 '각 나머지별 합'이라는 변수에 저장한다.
        sum_by_rem[i % 3] = sum_by_rem[i % 3 + 3]
        sum_by_rem[i % 3 + 3] = (sum_by_rem[i % 3 + 3] + dy[-1]) % BIG_NUM

    return dy[n]
